<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Sci-analysis : A light weight python data analysis and data exploration tool">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Sci-analysis</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/cmmorrow/sci-analysis">View on GitHub</a>

          <h1 id="project_title">Sci-analysis</h1>
          <h2 id="project_tagline">A light weight python data analysis and data exploration tool</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/cmmorrow/sci-analysis/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/cmmorrow/sci-analysis/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="sci-analysis" class="anchor" href="#sci-analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>sci-analysis</h1>

<p>A light weight python data exploration and analysis tool by Chris Morrow</p>

<h2>
<a id="current-version" class="anchor" href="#current-version" aria-hidden="true"><span class="octicon octicon-link"></span></a>Current Version:</h2>

<p>1.2 --- Released May 26, 2015</p>

<h3>
<a id="what-is-sci_analysis" class="anchor" href="#what-is-sci_analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>What is sci_analysis?</h3>

<p>Sci_analysis is a python module for performing rapid statistical data analysis. It provides a graphical representation of the supplied data as well as the statistical analysis. Sci_analysis is smart enough to determine the correct analysis and tests to perform based on the shape of the data you provide, as well as whether the data is normally distributed.</p>

<p>Currently, sci_analysis can only be used for analyzing numeric data. Categorical data analysis is planned for a future version. The three types of analysis that can be performed are histograms of single vectors, correlation between two vectors and one-way ANOVA.</p>

<h3>
<a id="getting-started-with-sci_analysis" class="anchor" href="#getting-started-with-sci_analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Getting started with sci_analysis</h3>

<p>Before using sci_analysis, be sure the following three packages are installed:</p>

<ul>
<li>numpy</li>
<li>scipy</li>
<li>matplotlib</li>
</ul>

<p>Sci_analysis is also compatible with pandas and works best in the iPython Notebook.</p>

<p>First, download to your PC or clone the repo at: 
<a href="https://github.com/cmmorrow/sci-analysis">https://github.com/cmmorrow/sci-analysis</a></p>

<p>Next, add the sci_analysis directory to your project with:</p>

<div class="highlight highlight-python"><pre>sys.path.extend([<span class="pl-s"><span class="pl-pds">'</span>&lt;path to directory&gt;/sci_analysis<span class="pl-pds">'</span></span>])
<span class="pl-k">import</span> scianalysis <span class="pl-k">as</span> a
<span class="pl-k">import</span> numpy <span class="pl-k">as</span> np</pre></div>

<p>This will tell python were to find sci_analysis and import it to your project as the object <code>a</code>. </p>

<p>If you are using the iPython Notebook, you will also want to use the following code instead to enable inline plots:</p>

<div class="highlight highlight-python"><pre><span class="pl-k">%</span>matplotlib inline
<span class="pl-k">import</span> matplotlib
sys.path.extend([<span class="pl-s"><span class="pl-pds">'</span>&lt;path to directory&gt;/sci_analysis<span class="pl-pds">'</span></span>])
<span class="pl-k">import</span> scianalysis <span class="pl-k">as</span> a
<span class="pl-k">import</span> numpy <span class="pl-k">as</span> np</pre></div>

<p>Now, sci_analysis should be ready to use. Try the following code:</p>

<div class="highlight highlight-python"><pre>a.analyze(np.random.randn(<span class="pl-c1">100</span>))</pre></div>

<p>A histogram and box plot of the data should appear, as well as printed output similar to that below:</p>

<pre><code>Statistics
--------
Count = 100
Mean = -0.0346394170379
Standard Deviation = 1.00138009977
Skewness = 0.246797356486
Kurtosis = 0.0301715149203
Max = 2.98521191579
75% = 0.618195797909
50% = -0.1045351866
25% = -0.760766375821
Min = -2.43834596493
IQR = 1.37896217373
Range = 5.42355788072

Shapiro-Wilk test for normality
--------
W value = 0.9944
p value = 0.9581
H0: Data is normally distributed
</code></pre>

<p>You should probably note that numpy was only imported for the purpose of the above example. Sci_analysis uses numpy internally, so it isn't necessary to import it unless you want to explicitly use it. Sci_analysis can work with regular python sequences as in the following:</p>

<div class="highlight highlight-python"><pre>In[<span class="pl-c1">6</span>]: a.clean([<span class="pl-c1">6</span>, <span class="pl-c1">9</span>, <span class="pl-c1">12</span>, <span class="pl-c1">15</span>])
Out[<span class="pl-c1">6</span>]: array([ <span class="pl-c1">6</span>,  <span class="pl-c1">9</span>, <span class="pl-c1">12</span>, <span class="pl-c1">15</span>])

In[<span class="pl-c1">7</span>]: a.clean((<span class="pl-c1">4</span>, <span class="pl-c1">8</span>, <span class="pl-c1">12</span>, <span class="pl-c1">16</span>, <span class="pl-c1">20</span>))
Out[<span class="pl-c1">7</span>]: array([ <span class="pl-c1">4</span>,  <span class="pl-c1">8</span>, <span class="pl-c1">12</span>, <span class="pl-c1">16</span>, <span class="pl-c1">20</span>])</pre></div>

<p>Sci_analysis is also compatible with the pandas Series object. To use pandas with sci_analysis, be sure to import it to your project with:</p>

<div class="highlight highlight-python"><pre><span class="pl-k">import</span> pandas <span class="pl-k">as</span> pd</pre></div>

<p>The sci_analysis helper functions can accept a pandas Series object and return a Series as in the example below:</p>

<div class="highlight highlight-python"><pre>In[<span class="pl-c1">9</span>]: a.clean(pd.Series([<span class="pl-c1">6</span>, <span class="pl-c1">9</span>, <span class="pl-c1">12</span>, <span class="pl-c1">15</span>]))
Out[<span class="pl-c1">9</span>]: 
<span class="pl-c1">0</span>     <span class="pl-c1">6</span>
<span class="pl-c1">1</span>     <span class="pl-c1">9</span>
<span class="pl-c1">2</span>    <span class="pl-c1">12</span>
<span class="pl-c1">3</span>    <span class="pl-c1">15</span>
dtype: int64</pre></div>

<h3>
<a id="how-do-i-use-sci_analysis" class="anchor" href="#how-do-i-use-sci_analysis" aria-hidden="true"><span class="octicon octicon-link"></span></a>How do I use sci_analysis?</h3>

<p>The easiest and fastest way to use sci_analysis is to call it's <code>analyze</code> function. Here's the signature for the <code>analyze</code> function:</p>

<div class="highlight highlight-python"><pre><span class="pl-k">def</span> <span class="pl-en">analyze</span>(<span class="pl-smi">xdata</span>, <span class="pl-smi">ydata</span><span class="pl-k">=</span>[], <span class="pl-smi">groups</span><span class="pl-k">=</span>[], <span class="pl-smi">name</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-smi">xname</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>, <span class="pl-smi">yname</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>y<span class="pl-pds">'</span></span>, <span class="pl-smi">alpha</span><span class="pl-k">=</span><span class="pl-c1">0.05</span>, <span class="pl-smi">categories</span><span class="pl-k">=</span><span class="pl-s"><span class="pl-pds">'</span>Categories<span class="pl-pds">'</span></span>):</pre></div>

<p><code>analyze</code> will detect the desired type of data analysis to perform based on whether the <code>ydata</code> argument is supplied, and whether the <code>xdata</code> argument is a two-dimensional array-like object. </p>

<p>The <code>xdata</code> and <code>ydata</code> arguments can accept most python iterable objects, with the exception of strings. For example, <code>xdata</code> will accept a python list or tuple, a numpy ndarray, or a pandas Series. Internally, lists and tuples are converted to ndarrays and Series objects are manipulated using the ndarray methods.</p>

<p>If only the <code>xdata</code> argument is passed and it is a one-dimensional vector, the analysis performed will be a histogram of the vector with basic statistics and Shapiro-Wilk normality test. This is useful for visualizing the distribution of the vector.</p>

<p>If <code>xdata</code> and <code>ydata</code> are supplied and are both one-dimensional vectors, the correlation between the two vectors will be graphed and calculated. If there are non-numeric or missing values in either vector, they will be ignored. Only values that are numeric in each vector, at the same index will be included in the correlation. For example, the two following vectors will yield:</p>

<div class="highlight highlight-python"><pre>In[<span class="pl-c1">24</span>]: example1 <span class="pl-k">=</span> numpy.array([<span class="pl-c1">1.0</span>, <span class="pl-c1">2.0</span>, <span class="pl-c1">float</span>(<span class="pl-s"><span class="pl-pds">'</span>nan<span class="pl-pds">'</span></span>), <span class="pl-c1">4.0</span>, <span class="pl-c1">float</span>(<span class="pl-s"><span class="pl-pds">'</span>nan<span class="pl-pds">'</span></span>), <span class="pl-c1">6.0</span>])
In[<span class="pl-c1">25</span>]: example2 <span class="pl-k">=</span> numpy.array([<span class="pl-c1">10.0</span>, <span class="pl-c1">20.0</span>, <span class="pl-c1">float</span>(<span class="pl-s"><span class="pl-pds">'</span>nan<span class="pl-pds">'</span></span>), <span class="pl-c1">40.0</span>, <span class="pl-c1">50.0</span>, <span class="pl-c1">60.0</span>])
In[<span class="pl-c1">26</span>]: a.dropnan_intersect(example1, example2)

Out[<span class="pl-c1">26</span>]: (array([ <span class="pl-c1">1.</span>,  <span class="pl-c1">2.</span>,  <span class="pl-c1">4.</span>,  <span class="pl-c1">6.</span>]), array([ <span class="pl-c1">10.</span>,  <span class="pl-c1">20.</span>,  <span class="pl-c1">40.</span>,  <span class="pl-c1">60.</span>]))</pre></div>

<p>The <code>dropnan_intersect</code> function performs what the name implies --- any values that are not-a-number in either vector at the same index will be dropped from the output tuple. It's also important to note that both vector lengths must be equal.</p>

<p>If <code>xdata</code> is a sequence of vectors, summary statistics will be reported for each vector. If the concatenation of each vector is normally distributed and they all have equal variance, a one-way ANOVA is performed. If the data is not normally distributed or the vectors do not have equal variance, a non-parametric Kruskal-Wallis test will be performed instead of a one-way ANOVA.</p>

<p>It is important to note that the vectors should be independent from one another --- that is to say, there should not be values in one vector that are derived from or some how related to a value in another vector. These dependencies can lead to weird and often unpredictable results. For example, a proper use case would be if you had a vector with measurement data and another vector (or vectors) that represent a grouping applied to the measurement data. In this case, each group should be represented by it's own vector, which are then all wrapped in a sequence. the <code>analyze</code> function accepts a <code>groups</code> argument as a list of strings of grouping names. The order of the group names should match the order of the vectors passed to <code>xdata</code>. For example:</p>

<div class="highlight highlight-python"><pre>In[<span class="pl-c1">10</span>]: group_a <span class="pl-k">=</span> np.random.randn(<span class="pl-c1">6</span>)
In[<span class="pl-c1">11</span>]: group_b <span class="pl-k">=</span> np.random.randn(<span class="pl-c1">7</span>)
In[<span class="pl-c1">12</span>]: group_c <span class="pl-k">=</span> np.random.randn(<span class="pl-c1">5</span>)
In[<span class="pl-c1">13</span>]: group_d <span class="pl-k">=</span> np.random.randn(<span class="pl-c1">8</span>)
In[<span class="pl-c1">14</span>]: names <span class="pl-k">=</span> [<span class="pl-s"><span class="pl-pds">"</span>group_a<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>group_b<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>group_c<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>group_d<span class="pl-pds">"</span></span>]
In[<span class="pl-c1">17</span>]: data <span class="pl-k">=</span> [group_a, group_b, group_c, group_d]
In[<span class="pl-c1">18</span>]: a.analyze(data, <span class="pl-smi">groups</span><span class="pl-k">=</span>names)
Count     Mean      Std.      Max       <span class="pl-c1">50</span><span class="pl-k">%</span>       Min       Group
<span class="pl-k">----------------------------------------------------------------------</span>
<span class="pl-c1">6</span>         <span class="pl-c1">0.280</span>     <span class="pl-c1">1.008</span>     <span class="pl-c1">1.489</span>     <span class="pl-c1">0.458</span>     <span class="pl-k">-</span><span class="pl-c1">1.555</span>    group_a   
<span class="pl-c1">7</span>         <span class="pl-c1">0.131</span>     <span class="pl-c1">1.596</span>     <span class="pl-c1">1.980</span>     <span class="pl-c1">0.678</span>     <span class="pl-k">-</span><span class="pl-c1">2.058</span>    group_b   
<span class="pl-c1">5</span>         <span class="pl-k">-</span><span class="pl-c1">0.300</span>    <span class="pl-c1">0.932</span>     <span class="pl-c1">1.061</span>     <span class="pl-k">-</span><span class="pl-c1">0.457</span>    <span class="pl-k">-</span><span class="pl-c1">1.428</span>    group_c   
<span class="pl-c1">8</span>         <span class="pl-c1">0.246</span>     <span class="pl-c1">0.944</span>     <span class="pl-c1">1.964</span>     <span class="pl-c1">0.369</span>     <span class="pl-k">-</span><span class="pl-c1">1.284</span>    group_d   

Bartlett Test
<span class="pl-k">--------</span>
T value <span class="pl-k">=</span> <span class="pl-c1">2.3708</span>
p value <span class="pl-k">=</span> <span class="pl-c1">0.4991</span>
H0: Variances are equal

ANOVA
<span class="pl-k">--------</span>
f value <span class="pl-k">=</span> <span class="pl-c1">0.2832</span>
p value <span class="pl-k">=</span> <span class="pl-c1">0.8369</span>
H0: Group means are matched</pre></div>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Sci-analysis maintained by <a href="https://github.com/cmmorrow">cmmorrow</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
